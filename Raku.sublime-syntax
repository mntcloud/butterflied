%YAML 1.2
---
# See http://www.sublimetext.com/docs/3/syntax.html
file_extensions:
  - raku
  - rakutest
  - rakumod
  - t
scope: source.raku

# This syntax definition based on https://github.com/silentTeee/sublimetext3-perl6-syntax

contexts:
  # The prototype context is prepended to all contexts but those setting
  # meta_include_prototype: false.
  prototype:
    - include: in_line_comments
    - include: line_comments
    - include: doc_comments
    #- include: figure_brackets

  main:
    # The main context is the initial starting point of our syntax.
    # Include other contexts from here (or specify them directly).
    - include: regex
    - include: keywords

    # like {} () [] and ;
    - include: sections

    - include: vars

    # NOTE: write before comprassion operators
    - include: angle_quote_strings
    - include: operators

    - include: numbers
    - include: double_quote_strings
    - include: single_qoute_strings
    - include: heredoc_string
    - include: built_in_consts

    - include: storage_types
    - include: storage_modifier
    - include: trait

    - include: built_in_subs

  keywords:
    # Keywords are if, else for and while.
    # Note that blackslashes don't need to be escaped within single quoted
    # strings in YAML. When using single quoted strings, only single quotes
    # need to be escaped: this is done by using two single quotes next to each
    # other.
    - match: '\b(if|elsif|else|unless|with|for|given|when|default|loop|my|while|return|returns|repeat|until|orwith|without|use|is|has|try|gather|start|react|supply|tap|emit|does|self|fail|enum|role|constant|unit|module|our|subset)\b'
      scope: keyword.control.raku

  built_in_subs:
    - match: '\b(say|print|uc|chars|flip|numerator|denominator|nude|is-prime|WHAT|slurp|warn|IO|lines|mkdir|rmdir|e|map|reverse|exit|sort|unique|kv|keys|values|open|get|push|prompt|run|shell|spurt|dir|die|defined|last|do)\b'
      scope: support.function.raku

  vars:
    - match: '(\$|@|%|&)\S+?.\b'
      captures:
        1: punctuation.definition.variable
      scope: variable.other.raku

  regex:
    - match: '(?x)(?<= ^ | ^\s | rx | [\s\(] [^\p{Nd}\p{L}] | ~~\s|~~\s\s|match\( | match:\s)(?<! [\$\/]) ([/]) (.*) ([/])'
      captures:
        1: string.regexp.begin.raku
        2: string.regexp.raku
        3: string.regexp.end.raku


  operators:
    - include: simple_operators
    - include: word_operators
    - include: access_operator
    - include: multi_symbol_operators

  simple_operators:
    - match: '(?x) (?<!\(|\*)\%| [\^\+><\*\!=\?~\/\|]| (?<!\$)\.| (?<!:):(?!:)| (?<=\s)\-(?=[\s\(\{\[])| (?<!\w)[o\x{2218}](?!\w)'
      scope: keyword.operator.generic.raku

  access_operator:
    - match: '(?x)\b(?<![\-])( :: )?(exists)(?!\-)\b(?!\s*=>)'
      scope: keyword.operator.colon.raku

  word_operators:
    - match: '(?x)\b(?<!\$|@|&|%)( div|mod|gcd|lcm|x|xx|temp|let|but|cmp|leg| eq|ne|gt|ge|lt|le|before|after|eqv|min|max|ff|fff|not|so|Z| and|andthen|or|orelse )\b(?!\-)| \b(X)(?!:)\b'
      scope: keyword.operator.word.raku

  multi_symbol_operators:
    - match: '(?x) <== | ==> | <=> | => | --> | -> | \+\| | \+\+ | -- | \*\* | \?\?\? | \?\? | \!\!\! | \!\! | && | \+\^ | \?\^ | %% | \+& | \+< | \+> | \+\^ | \.\.(?!\.) | \.\.\^ | \^\.\. | \^\.\.\^ | \?\| | !=(?!\=) | !==(?!\=) | <=(?!>) | >= | === | == | =:= | ~~ | \x{2245} | \|\| | \^\^ | \/\/ | := | ::= | \.\.\.'
      scope: keyword.operator.multi-symbol.raku


  numbers:
    - match: '\b(\-)?[0-9]*\.?[0-9]+\b'
      scope: constant.numeric.raku
    - match: '\b0x[0-9a-fA-F_]+\b'
      scope: constant.numeric.raku
    - match: '\b0b[0-1_]+\b'
      scope: constant.numeric.raku
    - match: '\b0o[0-7_]+\b'
      scope: constant.numeric.raku

  built_in_consts:
    - match: '\b(True|False|Nil)\b'
      scope: constant.language.raku

  trait:
    - match: '(?x)\b(?<![\-:])( prec|irs|ofs|ors|export|raw|deep |binary|unary|reparsed|rw|parsed |cached|readonly|defequiv|will |ref|copy|inline|tighter|looser |equiv|assoc|required|pure )(?!\-)\b  (?!\s*=>)'
      scope: entity.name.trait.raku

  storage_types:
    - match: '\b(Mu|Any|Cool|Str|Int|Rat|Bool|Sub|u?int8|u?int16|u?int32|u?int64|byte|num32|num64|token|regex|rule)\b'
      scope: storage.type.raku
    - match: '\b(sub|multi|submethod|method)\b ([A-Za-z0-9_\-!]+)'
      scope: storage.type.raku
      captures:
        1: meta.function.raku
        2: entity.name.function.raku
    - match: '\b(class)\b ([A-Za-z0-9-_:]+)'
      scope: storage.type.raku
      captures:
        1: meta.class.raku
        2: entity.name.class.raku
    - match: '\b(grammar)\b ([A-Za-z0-9_-]+)'
      scope: storage.type.raku
      captures:
        1: meta.grammar.raku
        2: entity.name.grammar.raku

  storage_modifier:
    - match: '(?x)\b(?<![\-:]) (is|does|as|but|trusts|of|returns|handles|where|augment|supersede) (?!\-)\b (?!\s*=>)'
      scope: storage.modifier.type.constraints.raku

  char_escapes:
    - match: '\.'
      scope: constant.character.escape.raku

  heredoc_string:
    - match: 'q:to\/(.*)\/;\s?+'
      push: inside_heredoc_string

  inside_heredoc_string:
    - meta_include_prototype: false
    - meta_content_scope: string.multiline.raku
    - include: char_escapes
    - match: ^\1
      pop: true

  double_quote_strings:
    # interpolated strings begin and end with double quotes, and use backslashes as an escape
    # character.
    - match: '"'
      scope: punctuation.definition.string.begin.raku
      push: inside_double_quote_string

  inside_double_quote_string:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.raku
    - include: char_escapes
    - match: '(?<![\\])"'
      scope: punctuation.definition.string.end.raku
      pop: true

  single_qoute_strings:
    # literal strings begin and end with single quotes, no escapes
    - match: ''''
      scope: punctuation.definition.string.begin.raku
      push:
        - meta_include_prototype: false
        - meta_scope: string.quoted.single.raku
        - match: ''''
          scope: punctuation.definition.string.end.raku
          pop: true

  angle_quote_strings:
    - match: '<([^\n>]+)>'
      captures:
        1: string.angled.raku
      pop: true

  sections:
    # literal strings begin and end with single quotes, no escapes
    - match: '{|\[|\(|\)|\]|}|;'
      scope: punctuation.section.raku

  line_comments:
    # line_comments begin with a '#' and finish at the end of the line.
    - match: '#'
      scope: punctuation.definition.comment.raku
      push:
        # This is an anonymous context push for brevity.
        - meta_scope: comment.line.number-sign.raku
        - match: $\n?
          pop: true

  doc_comments:
    # doc_comments begin with a '=begin <tagname>\n' and end with a
    # '=end <tagname>\n' string
    - match: '^=begin \S+\n'
      scope: punctuation.definition.comment.raku
      push:
        # This is an anonymous context push for brevity.
        - meta_include_prototype: false
        - meta_scope: comment.block.documentation.raku
        - match: '^=end \S+\n'
          pop: true

  in_line_comments:
    - match: '#`\('
      scope: punctuation.definition.comment.raku
      push:
        # This is an anonymous context push for brevity.
        - meta_include_prototype: false
        - meta_scope: comment.block.raku
        - include: matching_parentheses
        - match: '\)'
          pop: true
    - match: '#`\['
      scope: punctuation.definition.comment.raku
      push:
        # This is an anonymous context push for brevity.
        - meta_include_prototype: false
        - meta_scope: comment.block.raku
        - include: matching_square_brackets
        - match: '\]'
          pop: true
    - match: '#`\{'
      scope: punctuation.definition.comment.raku
      push:
        # This is an anonymous context push for brevity.
        - meta_include_prototype: false
        - meta_scope: comment.block.raku
        - include: matching_curly_brackets
        - match: '\}'
          pop: true
    - match: '#`\<'
      scope: punctuation.definition.comment.raku
      push:
        # This is an anonymous context push for brevity.
        - meta_include_prototype: false
        - meta_scope: comment.block.raku
        - include: matching_angle_brackets
        - match: '\>'
          pop: true

  # TODO: interpolation
  # interpolation:

  # These contexts are pretty much exclusively for nested brackets in comments
  matching_parentheses:
    - match: '\('
      push:
        # This is an anonymous context push for brevity.
        - meta_include_prototype: false
        - include: matching_parentheses
        - match: '\)'
          pop: true

  matching_square_brackets:
    - match: '\['
      push:
        # This is an anonymous context push for brevity.
        - meta_include_prototype: false
        - include: matching_square_brackets
        - match: '\]'
          pop: true

  matching_curly_brackets:
    - match: '\{'
      push:
        # This is an anonymous context push for brevity.
        - meta_include_prototype: false
        - include: matching_curly_brackets
        - match: '\}'
          pop: true

  matching_angle_brackets:
    - match: '\<'
      push:
        # This is an anonymous context push for brevity.
        - meta_include_prototype: false
        - include: matching_angle_brackets
        - match: '\>'
          pop: true